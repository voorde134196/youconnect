{
  "_args": [
    [
      {
        "raw": "rsvp@^4.8.4",
        "scope": null,
        "escapedName": "rsvp",
        "name": "rsvp",
        "rawSpec": "^4.8.4",
        "spec": ">=4.8.4 <5.0.0",
        "type": "range"
      },
      "J:\\Projects\\youconnect\\node_modules\\capture-exit"
    ]
  ],
  "_from": "rsvp@^4.8.4",
  "_hasShrinkwrap": false,
  "_id": "rsvp@4.8.5",
  "_location": "/rsvp",
  "_nodeVersion": "11.10.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/rsvp_4.8.5_1559843747770_0.6738829267050814"
  },
  "_npmUser": {
    "name": "stefanpenner",
    "email": "stefan.penner@gmail.com"
  },
  "_npmVersion": "6.7.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "rsvp@^4.8.4",
    "scope": null,
    "escapedName": "rsvp",
    "name": "rsvp",
    "rawSpec": "^4.8.4",
    "spec": ">=4.8.4 <5.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/capture-exit"
  ],
  "_resolved": "https://registry.npmjs.org/rsvp/-/rsvp-4.8.5.tgz",
  "_shasum": "c8f155311d167f68f21e168df71ec5b083113734",
  "_shrinkwrap": null,
  "_spec": "rsvp@^4.8.4",
  "_where": "J:\\Projects\\youconnect\\node_modules\\capture-exit",
  "author": {
    "name": "Tilde, Inc. & Stefan Penner"
  },
  "browser": {
    "vertx": false
  },
  "bugs": {
    "url": "https://github.com/tildeio/rsvp.js/issues"
  },
  "dependencies": {},
  "description": "A lightweight library that provides tools for organizing asynchronous code",
  "devDependencies": {
    "babel-plugin-transform-es2015-arrow-functions": "^6.22.0",
    "babel-plugin-transform-es2015-block-scoping": "6.26.0",
    "babel-plugin-transform-es2015-classes": "^6.24.1",
    "babel-plugin-transform-es2015-computed-properties": "^6.24.1",
    "babel-plugin-transform-es2015-constants": "^6.1.4",
    "babel-plugin-transform-es2015-destructuring": "^6.23.0",
    "babel-plugin-transform-es2015-parameters": "^6.24.1",
    "babel-plugin-transform-es2015-shorthand-properties": "^6.24.1",
    "babel-plugin-transform-es2015-spread": "^6.22.0",
    "babel-plugin-transform-es2015-template-literals": "^6.22.0",
    "babel-preset-env": "1.7.0",
    "babel6-plugin-strip-class-callcheck": "^6.0.0",
    "broccoli-babel-transpiler": "6.4.3",
    "broccoli-concat": "^3.7.1",
    "broccoli-funnel": "2.0.1",
    "broccoli-merge-trees": "^3.0.1",
    "broccoli-rollup": "2.1.1",
    "broccoli-stew": "^2.0.0",
    "broccoli-uglify-js": "^0.2.0",
    "broccoli-watchify": "1.0.1",
    "ember-cli": "3.4.2",
    "ember-cli-dependency-checker": "3.0.0",
    "ember-cli-inject-live-reload": "^2.0.1",
    "ember-cli-progress": "^1.0.6",
    "git-repo-version": "1.0.2",
    "mocha": "5.2.0",
    "promises-aplus-tests": "2.1.2"
  },
  "directories": {
    "lib": "lib"
  },
  "dist": {
    "integrity": "sha512-nfMOlASu9OnRJo1mbEk2cz0D56a1MBNrJ7orjRZQG10XDyuvwksKbuXNp6qa+kbn839HwjwhBzhFmdsaEAfauA==",
    "shasum": "c8f155311d167f68f21e168df71ec5b083113734",
    "tarball": "https://registry.npmjs.org/rsvp/-/rsvp-4.8.5.tgz",
    "fileCount": 36,
    "unpackedSize": 644259,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJc+VOkCRA9TVsSAnZWagAA2L4P/iTi0M2n/ZzlTka2C/Ns\nZ+UWL0fXfNbpNsM4xhYAAieZh2zXjoGUV0kPANSoZ72TmrSYGCjrEutAbAVN\nBPPm8HrC8FsMSvzal4UtJDgkS4lmjujjPSTMiIcSrMxORIBnwzMU1hBetsVs\n4+K5Z787Klu5/ajCGLl83LIFwtlYOVUvYr6wO3Ae55NKR99+A92fcwIzV0YG\nE1bOffqcmeIkMRoyI5w5T+CTVbPIbiInrLIa0wAMq6PaNGqQRMhfvAKjgMPP\nS5ZXqEmjZCFvKtGZJdZUTg9FNEVzZp0N5L/B54lf666Cdj3Ah+P6Soh36SeO\nzOCpMBwXXrDsWviedORBzGoROQjdfbQOedJCuR3ubLNpA4RIDOVVG60qMXnf\niMG4/tlmkPnlZ5r5Vjxe8hs4fplmKC3olPoClBefLoRF9/owQOghqLm4BlU1\ni+YNtN8SGxrmb3cwZ3ULmAyt8PzlhJZ52gETGAtNFY0cjrFUBq9OAO44vxIZ\nP5lkMaZyhPfEKQY3Be7owsqB8kwhxWgDTMODe/d3vLyZ6k+dkzAKXlSraAle\nocUe/F1OCK2XYPWBGDRf5UPoSnGG1Q0Qcz2IupASeE2L7qYLjMBrQaBD6w0y\nFubOwT1dcbNtxztHQerw6gfKQw/Y6t7Pdfgd7WP8zvMx2fR3JbxhYWStG91y\nh2le\r\n=srP/\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "engines": {
    "node": "6.* || >= 7.*"
  },
  "files": [
    "dist",
    "lib",
    "!dist/test"
  ],
  "gitHead": "c47347960d1a00e16f3d8ae7d69fa8c296d7d05a",
  "homepage": "https://github.com/tildeio/rsvp.js",
  "jsnext:main": "dist/rsvp.es.js",
  "keywords": [
    "futures",
    "promises"
  ],
  "license": "MIT",
  "main": "dist/rsvp.js",
  "maintainers": [
    {
      "name": "fivetanley",
      "email": "stanley@stan.li"
    },
    {
      "name": "mixonic",
      "email": "matt.beale@madhatted.com"
    },
    {
      "name": "rwjblue",
      "email": "me@rwjblue.com"
    },
    {
      "name": "ryanflorence",
      "email": "rpflorence@gmail.com"
    },
    {
      "name": "stefanpenner",
      "email": "stefan.penner@gmail.com"
    },
    {
      "name": "wycats",
      "email": "wycats@gmail.com"
    }
  ],
  "module": "dist/rsvp.es.js",
  "name": "rsvp",
  "namespace": "RSVP",
  "optionalDependencies": {},
  "readme": "# RSVP.js  [![Build Status](https://secure.travis-ci.org/tildeio/rsvp.js.svg?branch=master)](http://travis-ci.org/tildeio/rsvp.js) [![Inline docs](http://inch-ci.org/github/tildeio/rsvp.js.svg?branch=master)](http://inch-ci.org/github/tildeio/rsvp.js)\nRSVP.js provides simple tools for organizing asynchronous code.\n\nSpecifically, it is a tiny implementation of Promises/A+.\n\nIt works in node and the browser (IE9+, all the popular evergreen ones).\n\n## downloads\n\n- rsvp ([latest](https://cdn.jsdelivr.net/npm/rsvp/dist/rsvp.js) | [4.x](https://cdn.jsdelivr.net/npm/rsvp@4/dist/rsvp.js))\n- rsvp minified ([latest](https://cdn.jsdelivr.net/npm/rsvp/dist/rsvp.min.js) | [4.x](https://cdn.jsdelivr.net/npm/rsvp@4/dist/rsvp.min.js))\n\n## CDN\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/rsvp@4/dist/rsvp.min.js\"></script>\n```\n\n## Promises\n\nAlthough RSVP is ES6 compliant, it does bring along some extra toys. If you\nwould prefer a strict ES6 subset, I would suggest checking out our sibling\nproject https://github.com/stefanpenner/es6-promise, It is RSVP but stripped\ndown to the ES6 spec features.\n\n## Node\n\n```sh\nyarn add --save rsvp\n# or ...\nnpm install --save rsvp\n```\n\n`RSVP.Promise` is an implementation of\n[Promises/A+](http://promises-aplus.github.com/promises-spec/) that passes the\n[test suite](https://github.com/promises-aplus/promises-tests).\n\nIt delivers all promises asynchronously, even if the value is already\navailable, to help you write consistent code that doesn't change if the\nunderlying data provider changes from synchronous to asynchronous.\n\nIt is compatible with [TaskJS](https://github.com/mozilla/task.js), a library\nby Dave Herman of Mozilla that uses ES6 generators to allow you to write\nsynchronous code with promises. It currently works in Firefox, and will work in\nany browser that adds support for ES6 generators. See the section below on\nTaskJS for more information.\n\n### Basic Usage\n\n```javascript\nvar RSVP = require('rsvp');\n\nvar promise = new RSVP.Promise(function(resolve, reject) {\n  // succeed\n  resolve(value);\n  // or reject\n  reject(error);\n});\n\npromise.then(function(value) {\n  // success\n}).catch(function(error) {\n  // failure\n});\n```\n\nOnce a promise has been resolved or rejected, it cannot be resolved or rejected\nagain.\n\nHere is an example of a simple XHR2 wrapper written using RSVP.js:\n\n```javascript\nvar getJSON = function(url) {\n  var promise = new RSVP.Promise(function(resolve, reject){\n    var client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n\n    function handler() {\n      if (this.readyState === this.DONE) {\n        if (this.status === 200) { resolve(this.response); }\n        else { reject(this); }\n      }\n    };\n  });\n\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  // continue\n}).catch(function(error) {\n  // handle errors\n});\n```\n\n### Chaining\n\nOne of the really awesome features of Promises/A+ promises are that they can be\nchained together. In other words, the return value of the first\nresolve handler will be passed to the second resolve handler.\n\nIf you return a regular value, it will be passed, as is, to the next handler.\n\n```javascript\ngetJSON(\"/posts.json\").then(function(json) {\n  return json.post;\n}).then(function(post) {\n  // proceed\n});\n```\n\nThe really awesome part comes when you return a promise from the first handler:\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post) {\n  // save off post\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // proceed with access to post and comments\n});\n```\n\nThis allows you to flatten out nested callbacks, and is the main feature of\npromises that prevents \"rightward drift\" in programs with a lot of asynchronous\ncode.\n\nErrors also propagate:\n\n```javascript\ngetJSON(\"/posts.json\").then(function(posts) {\n\n}).catch(function(error) {\n  // since no rejection handler was passed to the\n  // first `.then`, the error propagates.\n});\n```\n\nYou can use this to emulate `try/catch` logic in synchronous code. Simply chain\nas many resolve callbacks as you want, and add a failure handler at the end to\ncatch errors.\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // proceed with access to posts and comments\n}).catch(function(error) {\n  // handle errors in either of the two requests\n});\n```\n\n## Error Handling\n\nThere are times when dealing with promises that it seems like any errors are\nbeing 'swallowed', and not properly raised. This makes it extremely difficult\nto track down where a given issue is coming from. Thankfully, `RSVP` has a\nsolution for this problem built in.\n\nYou can register functions to be called when an uncaught error occurs within\nyour promises. These callback functions can be anything, but a common practice\nis to call `console.assert` to dump the error to the console.\n\n```javascript\nRSVP.on('error', function(reason) {\n  console.assert(false, reason);\n});\n```\n\n`RSVP` allows Promises to be labeled: `Promise.resolve(value, 'I AM A LABEL')`\nIf provided, this label is passed as the second argument to `RSVP.on('error')`\n\n```javascript\nRSVP.on('error', function(reason, label) {\n  if (label) {\n    console.error(label);\n  }\n\n  console.assert(false, reason);\n});\n```\n\n\n**NOTE:** promises do allow for errors to be handled asynchronously, so this\ncallback may result in false positives.\n\n## Finally\n\n`finally` will be invoked regardless of the promise's fate, just as native\ntry/catch/finally behaves.\n\n```js\nfindAuthor().catch(function(reason){\n  return findOtherAuthor();\n}).finally(function(){\n  // author was either found, or not\n});\n```\n\n\n## Arrays of promises\n\nSometimes you might want to work with many promises at once. If you pass an\narray of promises to the `all()` method it will return a new promise that will\nbe fulfilled when all of the promises in the array have been fulfilled; or\nrejected immediately if any promise in the array is rejected.\n\n```javascript\nvar promises = [2, 3, 5, 7, 11, 13].map(function(id){\n  return getJSON(\"/post/\" + id + \".json\");\n});\n\nRSVP.all(promises).then(function(posts) {\n  // posts contains an array of results for the given promises\n}).catch(function(reason){\n  // if any of the promises fails.\n});\n```\n\n## Hash of promises\n\nIf you need to reference many promises at once (like `all()`), but would like\nto avoid encoding the actual promise order you can use `hash()`. If you pass an\nobject literal (where the values are promises) to the `hash()` method it will\nreturn a new promise that will be fulfilled when all of the promises have been\nfulfilled; or rejected immediately if any promise is rejected.\n\nThe key difference to the `all()` function is that both the fulfillment value\nand the argument to the `hash()` function are object literals. This allows you\nto simply reference the results directly off the returned object without having\nto remember the initial order like you would with `all()`.\n\n```javascript\nvar promises = {\n  posts: getJSON(\"/posts.json\"),\n  users: getJSON(\"/users.json\")\n};\n\nRSVP.hash(promises).then(function(results) {\n  console.log(results.users) // print the users.json results\n  console.log(results.posts) // print the posts.json results\n});\n```\n\n## All settled and hash settled\n\nSometimes you want to work with several promises at once, but instead of\nrejecting immediately if any promise is rejected, as with `all()` or `hash()`,\nyou want to be able to inspect the results of all your promises, whether they\nfulfill or reject. For this purpose, you can use `allSettled()` and\n`hashSettled()`. These work exactly like `all()` and `hash()`, except that they\nfulfill with an array or hash (respectively) of the constituent promises'\nresult states. Each state object will either indicate fulfillment or rejection,\nand provide the corresponding value or reason. The states will take\none of the following formats:\n\n```javascript\n{ state: 'fulfilled', value: value }\n  or\n{ state: 'rejected', reason: reason }\n```\n\n## Deferred\n\n> The `RSVP.Promise` constructor is generally a better, less error-prone choice\n> than `RSVP.defer()`. Promises are recommended unless the specific\n> properties of deferred are needed.\n\nSometimes one needs to create a deferred object, without immediately specifying\nhow it will be resolved. These deferred objects are essentially a wrapper\naround a promise, whilst providing late access to the `resolve()` and\n`reject()` methods.\n\nA deferred object has this form: `{ promise, resolve(x), reject(r) }`.\n\n```javascript\nvar deferred = RSVP.defer();\n// ...\ndeferred.promise // access the promise\n// ...\ndeferred.resolve();\n\n```\n\n## TaskJS\n\nThe [TaskJS](https://github.com/mozilla/task.js) library makes it possible to take\npromises-oriented code and make it synchronous using ES6 generators.\n\nLet's review an earlier example:\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // proceed with access to posts and comments\n}).catch(function(reason) {\n  // handle errors in either of the two requests\n});\n```\n\nWithout any changes to the implementation of `getJSON`, you could write\nthe following code with TaskJS:\n\n```javascript\nspawn(function *() {\n  try {\n    var post = yield getJSON(\"/post/1.json\");\n    var comments = yield getJSON(post.commentURL);\n  } catch(error) {\n    // handle errors\n  }\n});\n```\n\nIn the above example, `function *` is new syntax in ES6 for\n[generators](http://wiki.ecmascript.org/doku.php?id=harmony:generators). Inside\na generator, `yield` pauses the generator, returning control to the function\nthat invoked the generator. In this case, the invoker is a special function\nthat understands the semantics of Promises/A, and will automatically resume the\ngenerator as soon as the promise is resolved.\n\nThe cool thing here is the same promises that work with current\nJavaScript using `.then` will work seamlessly with TaskJS once a browser\nhas implemented it!\n\n## Instrumentation\n\n```js\nfunction listener (event) {\n  event.guid      // guid of promise. Must be globally unique, not just within the implementation\n  event.childGuid // child of child promise (for chained via `then`)\n  event.eventName // one of ['created', 'chained', 'fulfilled', 'rejected']\n  event.detail    // fulfillment value or rejection reason, if applicable\n  event.label     // label passed to promise's constructor\n  event.timeStamp // milliseconds elapsed since 1 January 1970 00:00:00 UTC up until now\n  event.stack     // stack at the time of the event. (if  'instrument-with-stack' is true)\n}\n\nRSVP.configure('instrument', true | false);\n// capturing the stacks is slow, so you also have to opt in\nRSVP.configure('instrument-with-stack', true | false);\n\n// events\nRSVP.on('created', listener);\nRSVP.on('chained', listener);\nRSVP.on('fulfilled', listener);\nRSVP.on('rejected', listener);\n```\n\nEvents are only triggered when `RSVP.configure('instrument')` is true, although\nlisteners can be registered at any time.\n\n## Building & Testing\n\nCustom tasks:\n\n* `npm test` - build & test\n* `npm test:node` - build & test just node\n* `npm test:server` - build/watch & test\n* `npm run build` - Build\n* `npm run build:production` - Build production (with minified output)\n* `npm start` - build, watch and run interactive server at http://localhost:4200'\n\n## Releasing\n\nCheck what release-it will do by running `npm run-script dry-run-release`.\nTo actually release, run `node_modules/.bin/release-it`.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/tildeio/rsvp.js.git",
    "dist": "git@github.com:components/rsvp.js.git"
  },
  "scripts": {
    "build": "ember build --environment production",
    "start": "ember s",
    "test": "ember test",
    "test:node": "ember test --launch Mocha",
    "test:server": "ember test --server"
  },
  "version": "4.8.5"
}
