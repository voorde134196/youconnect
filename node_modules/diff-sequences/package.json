{
  "_args": [
    [
      {
        "raw": "diff-sequences@^24.9.0",
        "scope": null,
        "escapedName": "diff-sequences",
        "name": "diff-sequences",
        "rawSpec": "^24.9.0",
        "spec": ">=24.9.0 <25.0.0",
        "type": "range"
      },
      "J:\\Projects\\youconnect\\node_modules\\jest-diff"
    ]
  ],
  "_from": "diff-sequences@^24.9.0",
  "_hasShrinkwrap": false,
  "_id": "diff-sequences@24.9.0",
  "_location": "/diff-sequences",
  "_nodeVersion": "11.12.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/diff-sequences_24.9.0_1565934946970_0.6896997727763712"
  },
  "_npmUser": {
    "name": "scotthovestadt",
    "email": "scott.hovestadt@gmail.com"
  },
  "_npmVersion": "lerna/3.15.0/node@v11.12.0+x64 (darwin)",
  "_phantomChildren": {},
  "_requested": {
    "raw": "diff-sequences@^24.9.0",
    "scope": null,
    "escapedName": "diff-sequences",
    "name": "diff-sequences",
    "rawSpec": "^24.9.0",
    "spec": ">=24.9.0 <25.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/jest-diff"
  ],
  "_resolved": "https://registry.npmjs.org/diff-sequences/-/diff-sequences-24.9.0.tgz",
  "_shasum": "5715d6244e2aa65f48bba0bc972db0b0b11e95b5",
  "_shrinkwrap": null,
  "_spec": "diff-sequences@^24.9.0",
  "_where": "J:\\Projects\\youconnect\\node_modules\\jest-diff",
  "bugs": {
    "url": "https://github.com/facebook/jest/issues"
  },
  "dependencies": {},
  "description": "Compare items in two sequences to find a longest common subsequence",
  "devDependencies": {
    "benchmark": "^2.1.4",
    "diff": "^4.0.1"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-Dj6Wk3tWyTE+Fo1rW8v0Xhwk80um6yFYKbuAxc9c3EZxIHFDYwbi34Uk42u1CdnIiVorvt4RmlSDjIPyzGC2ew==",
    "shasum": "5715d6244e2aa65f48bba0bc972db0b0b11e95b5",
    "tarball": "https://registry.npmjs.org/diff-sequences/-/diff-sequences-24.9.0.tgz",
    "fileCount": 8,
    "unpackedSize": 54116,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdVkVjCRA9TVsSAnZWagAAFZ0P/i1sacmf4y6R7vno4Mlg\n/lkFrIy5NnIuq0SiIkQr3J3dS0pViQK2WurJgw+m29Cf2Dfwl3l9nlhUAc5M\nGTuWDrFlIys04sgO+7gqvnZBYCxdCVoXSQKKof2KSD0urDkZiI27g1jYEYEm\nZw32R5YlCy0d5uOXxwTqTXZ8ESFTYOInR/kJdWUjl+8WR+So/aBptI/HUn7e\nYxqwl0FKKTVrW5gPhPD0mloCkUHRGy6QwlHg7eYDv9xuYoJrF0EWK6LSY4qo\nIGNiuXWAwY3gNWe9ttRIn8ystrsE0fKwIk3DlfbWJIgAsUkqZSIKSc92DcN0\nIX6YUEKmWfTLo/6J/8/ys4tlpMzJ+dXkSApCbddRC9DCUVsFeg/rgnwi3wCP\nRtbg9Nmxp4JmF4+GXbM596lrjBKhJFEvOoK9AzrlOIt/fdgg7Uer/jgKuc66\n/KeAOx04zwhk7yM07R3R613TupR+CvLXX0RXRcfHek6MKFkkWcuujtrE+szs\ngNJWznSq977vhIYncY0OkVxHaswy9632HiQa+cQDAkVSIpGC/rFdYWdDUjRk\nF0mHJMnZSaJJTtSTD/lj1tLxBRvXQa0uqsP44azcf1swlPjlTbRuX0IJxL9k\nB2eCXtGkl1aQYns0GwgVWgd15ys5JGNe45x6UUOOF/eOCaNmG5YXH6XSioyv\nRaLB\r\n=4z7W\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "engines": {
    "node": ">= 6"
  },
  "gitHead": "9ad0f4bc6b8bdd94989804226c28c9960d9da7d1",
  "homepage": "https://github.com/facebook/jest#readme",
  "keywords": [
    "fast",
    "linear",
    "space",
    "callback",
    "diff"
  ],
  "license": "MIT",
  "main": "build/index.js",
  "maintainers": [
    {
      "name": "cpojer",
      "email": "christoph.pojer@gmail.com"
    },
    {
      "name": "jeanlauliac",
      "email": "jean@lauliac.com"
    },
    {
      "name": "mjesun",
      "email": "mjesun@hotmail.com"
    },
    {
      "name": "rubennorte",
      "email": "rubennorte@gmail.com"
    },
    {
      "name": "scotthovestadt",
      "email": "scott.hovestadt@gmail.com"
    }
  ],
  "name": "diff-sequences",
  "optionalDependencies": {},
  "publishConfig": {
    "access": "public"
  },
  "readme": "# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/facebook/jest.git",
    "directory": "packages/diff-sequences"
  },
  "scripts": {
    "perf": "node --expose-gc perf/index.js"
  },
  "types": "build/index.d.ts",
  "version": "24.9.0"
}
